
# qhT* new_qhull_handler();
function new_qhull_handler()
    @check_if_loaded
    qh = Ptr{qhT}(Libc.malloc(sizeof(qhT)))
    qh_zero(qh, stderr.handle)
    return qh
end

# int delaunay_init_and_compute( int dim, int numpoints, coordT *points, int* numcells);
function delaunay_init_and_compute(qh::Ptr, dim::Int32, numpoints::Int32, points, numcells::Ref{Int32}, flags::Union{Ptr{Nothing},AbstractString})
    @check_if_loaded

    ismalloc = false

    if flags == C_NULL
        qhull_cmd = dim â‰¤ 3 ? "qhull d Qt Qbb Qc Qz" : "qhull d Qt Qbb Qc Qx"
    else
        qhull_cmd = flags
    end

    # Run qhull
    GC.@preserve qhull_cmd begin
        exitcode = qh_new_qhull(qh, dim, numpoints, points, ismalloc, qhull_cmd, C_NULL, stderr.handle)
    end
    exitcode != 0 && return exitcode

    # Triangulate all the non-simplex cells generated by qhull
    qh_triangulate(qh)

    # Count number of generated cells and double check that they are simplex
    facet = unsafe_load(qh.facet_list)
    numcells[] = 0
    while facet != C_NULL
        unsafe_load(facet.next) == C_NULL && break

        v = unsafe_load(facet)

        if !(v.upperdelaunay > 0)
            numcells[] += 1
        end

        if !(v.simplicial > 0)
            return -1
        end

        facet = unsafe_load(facet.next)
    end

    return 0
end


# int delaunay_fill_cells(int dim, int num_cells, int *cells);
function delaunay_fill_cells(qh::Ptr, dim::Int32, numcells::Int32, cells::Array{Int32})
    @check_if_loaded
    icell = 0
    facet = unsafe_load(qh.facet_list)
    vertex = Ptr{vertexT}(C_NULL)
    vertexp = Ptr{Ptr{vertexT}}(C_NULL)
    while facet != C_NULL
        unsafe_load(facet.next) == C_NULL && break

        v = unsafe_load(facet)

        if !(v.upperdelaunay > 0)
            ivertex = 1
            # Grrr, I hate macros...
            vertices = unsafe_load(facet.vertices)
            vertexp::Ptr{Ptr{vertexT}} = Ptr{setelemT}(vertices.e).p
            while vertices != C_NULL
                vertex = unsafe_load(vertexp)
                vertex == C_NULL && break

                cells[(dim+1)*icell+ivertex] = 1 + qh_pointid(qh, unsafe_load(vertex.point))
                ivertex += 1

                vertexp += sizeof(Ptr{vertexT})
            end
            icell += 1
        end

        facet = unsafe_load(facet.next)
    end

    return 0
end

#int delaunay_free()
function delaunay_free(qh::Ptr)
    @check_if_loaded
    curlong = Ref{Cint}(0)
    totlong = Ref{Cint}(0)
    qh_freeqhull(qh, !Bool(qh_ALL))
    qh_memfreeshort(qh, curlong, totlong)
    Libc.free(qh)
    if Bool(curlong[]) || Bool(totlong[])
        return -2
    end
    return 0
end
